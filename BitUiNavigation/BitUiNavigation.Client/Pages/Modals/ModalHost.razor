@inherits TimeWarpStateComponent
@inject NavigationManager Nav
@inject IModalProviderSource ModalProviderSource

@implements IDisposable
@using System.Web
@using BitUiNavigation.Client.Layout
@using Microsoft.AspNetCore.Components.Routing
@using BitUiNavigation.Client.Services

@if (_active is not null)
{
    <BitModal IsOpen="true"
              OnOverlayClick="@CloseAsync"
              OnDismiss="@CloseAsync"
              Classes="@ClassStyles">

        <BitStack Horizontal Gap="0rem" Style="height: 100%">
            <BitStack Class="nav-panel" FitWidth Style="border-top-left-radius:20px; border-bottom-left-radius:20px;">
                <BitButton Style="margin: 1rem 0 0 1rem"
                           Color="BitColor.Tertiary"
                           OnClick="@CloseAsync"
                           IconOnly
                           Size="BitSize.Small"
                           IconName="@BitIconName.ChromeClose"
                           Variant="BitVariant.Text" />
                <BitNav IsEnabled="@(!ModalHostState.IsSaving)"
                        Mode="BitNavMode.Automatic"
                        Items="@_active.BuildNavItems(Nav, _active.QueryKey)"
                        Match="BitNavMatch.Wildcard"
                        FitWidth
                        Style="margin:0 1rem"
                        Classes="NavStyles" />
            </BitStack>

            <div style="flex:1;display:flex;flex-direction:column;height:100%">
                <div style="flex-shrink:0;border-top-right-radius:20px;">
                    <BitStack Style="padding:1.25rem 1rem 1rem;"
                              Horizontal
                              VerticalAlign="BitAlignment.Baseline"
                              HorizontalAlign="BitAlignment.SpaceBetween">
                        <BitText Style="font-weight:600;font-size:16px;">
                            @ModalHostState.Title
                        </BitText>
                        <ModelStateStatus />
                    </BitStack>
                </div>

                <BitSeparator Border="BitColorKind.Tertiary" />

                <div style="flex:1;overflow:hidden;border-bottom-right-radius:20px;position:relative;">
                    <div style="height:100%;overflow-y:auto;">
                        <div style="padding:1rem;">
                            <CascadingValue TValue="@ModalGuardRegistration" Value="@RegisterGuardedComponent">
                                <RouteView @key="_section"
                                           RouteData="@_active.BuildRouteData(_section)"
                                           DefaultLayout="@typeof(EmptyLayout)" />
                            </CascadingValue>
                        </div>
                    </div>
                </div>
            </div>
        </BitStack>
    </BitModal>
}

<style>
    @((MarkupString)CreateContainerCss())

    .nav-panel {
        background-color: var(--bit-clr-bg-sec);
    }

    .nav-item-container {
        border-radius: 12px !important;
        margin-bottom: 4px !important;
        height: 18px !important;
    }

    .nav-selected-item-container {
        border-color: transparent !important;
    }
</style>

@code {
    private IModalProvider? _active;
    private string _section = string.Empty;
    private string? _preOpenUrl;
    private IModalSectionGuard? _currentGuardedComponent;

    private ModalHostState ModalHostState => GetState<ModalHostState>();

    BitModalClassStyles ClassStyles = new()
    {
        Content = ModalContainerClass,
    };
    BitNavClassStyles NavStyles => new()
    {
        SelectedItemContainer = "nav-selected-item-container",
        ItemContainer = "nav-item-container",
        Item = "nav-item",
        SelectedItem = "nav-selected-item",
    };

    private void RegisterGuardedComponent(IModalSectionGuard component)
        => _currentGuardedComponent = component;

    protected override void OnInitialized()
    {
        Nav.LocationChanged += OnLocationChanged;
        ReadFromUri(Nav.Uri, requestStateHasChanged: false);
    }

    protected override void OnAfterRender(bool firstRender)
    {
        if (firstRender)
        {
            ReadFromUri(Nav.Uri, requestStateHasChanged: true);
        }
    }

    private void OnLocationChanged(object? sender, LocationChangedEventArgs e)
        => ReadFromUri(e.Location, requestStateHasChanged: true);

    private async void ReadFromUri(string fullUri, bool requestStateHasChanged)
    {
        var uri = new Uri(fullUri);
        var qs = HttpUtility.ParseQueryString(uri.Query);

        var match = ModalProviderSource.GetModalProviders()
            .FirstOrDefault(p => !string.IsNullOrWhiteSpace(qs[p.QueryKey]));

        var newSection = match is null
            ? null
            : NormalizeSection(qs[match.QueryKey], match.DefaultSection);

        var wasActive = _active is not null;
        var willBeActive = match is not null;

        // Detect first open
        if (willBeActive && !wasActive)
        {
            // Store previous URL (to restore when modal closes)
            _preOpenUrl = RemoveQueryParam(fullUri, match!.QueryKey);

            // 🔔 call provider hook to initialize
            await match!.OnModalOpenedAsync(CancellationToken.None);
        }

        // Detect modal close
        if (!willBeActive && wasActive)
        {
            _preOpenUrl = null;
        }

        // Handle section change (panel navigation)
        _active = match;
        var oldSection = _section;
        _section = newSection ?? string.Empty;

        // Always allow navigation between panels (no validation / save here)
        // Just avoid duplicate navigation
        if (oldSection != _section)
        {
            // nothing else to do
        }

        if (requestStateHasChanged)
            StateHasChanged();
    }

    private async Task CloseAsync()
    {
        // Check with current panel guard before closing
        if (_currentGuardedComponent is not null)
        {
            var canClose = await _currentGuardedComponent.CanCloseModalAsync();
            if (!canClose)
                return;
        }

        // NOTE: saving should now be done either via a Save button OR by dispatching
        //       SaveUserActionSet.Action here (if you want "save on close").
        // await Store.Send(new SaveUserActionSet.Action());

        // Restore original URL
        if (!string.IsNullOrEmpty(_preOpenUrl))
        {
            Nav.NavigateTo(_preOpenUrl!, replace: true);
        }
        else if (_active is not null)
        {
            var stripped = Nav.GetUriWithQueryParameter(_active.QueryKey, (string?)null);
            Nav.NavigateTo(stripped, replace: true);
        }

        _preOpenUrl = null;
        _active = null;
        _section = string.Empty;
        _currentGuardedComponent = null;
    }

    private static string RemoveQueryParam(string fullUri, string key)
    {
        var uri = new Uri(fullUri);
        var qs = HttpUtility.ParseQueryString(uri.Query);
        qs.Remove(key);
        var ub = new UriBuilder(uri) { Query = qs.ToString() ?? string.Empty };
        return ub.Uri.ToString();
    }

    private static string NormalizeSection(string? value, string defaultSection)
    {
        if (string.IsNullOrWhiteSpace(value)) return defaultSection;
        var v = value.Trim();
        return v.StartsWith("/") ? v[1..] : v;
    }

    private static string ModalContainerClass = "modal-container";

    private string CreateContainerCss()
    {
        if (_active is null) return string.Empty;
        return $@"
        .{ModalContainerClass} {{
            width:  {_active.Width};
            height: {_active.Height};
            border-radius:20px;
        }}";
    }

    public override void Dispose()
    {
        Nav.LocationChanged -= OnLocationChanged;
        base.Dispose();
    }
}
