@inherits TimeWarpStateComponent
@inject NavigationManager Nav
@inject IModalProviderSource ModalProviderSource

@implements IDisposable
@using System.Web
@using BitUiNavigation.Client.Layout
@using Microsoft.AspNetCore.Components.Routing
@using BitUiNavigation.Client.Services
@using static BitUiNavigation.Client.Pages.Modals.UrlExtensions

@if (_activeModalProvider is not null)
{
    <BitModal IsOpen="true"
              OnOverlayClick="@CloseAsync"
              OnDismiss="@CloseAsync"
              Classes="@ClassStyles">

        <BitStack Horizontal Gap="0rem" Style="height: 100%">
            <BitStack Class="nav-panel" FitWidth Style="border-top-left-radius:20px; border-bottom-left-radius:20px;">
                <BitButton Style="margin: 1rem 0 0 1rem"
                           Color="BitColor.Tertiary"
                           OnClick="@CloseAsync"
                           IconOnly
                           Size="BitSize.Small"
                           IconName="@BitIconName.ChromeClose"
                           Variant="BitVariant.Text" />
                <BitNav IsEnabled="@(!ModalHostState.IsSaving)"
                        Mode="BitNavMode.Automatic"
                        Items="@_activeModalProvider.BuildNavItems(Nav, _activeModalProvider.ProviderKey)"
                        Match="BitNavMatch.Wildcard"
                        FitWidth
                        Style="margin:0 1rem"
                        Classes="NavStyles" />
            </BitStack>

            <div style="flex:1;display:flex;flex-direction:column;height:100%">
                <div style="flex-shrink:0;border-top-right-radius:20px;">
                    <BitStack Style="padding:1.25rem 1rem 1rem;"
                              Horizontal
                              VerticalAlign="BitAlignment.Baseline"
                              HorizontalAlign="BitAlignment.SpaceBetween">
                        <BitText Style="font-weight:600;font-size:16px;">
                            @ModalHostState.Title
                        </BitText>
                        <ModelStateStatus />
                    </BitStack>
                </div>

                <BitSeparator Border="BitColorKind.Tertiary" />

                <div style="flex:1;overflow:hidden;border-bottom-right-radius:20px;position:relative;">
                    <div style="height:100%;overflow-y:auto;">
                        <div style="padding:1rem;">
                            <CascadingValue TValue="@ModalGuardRegistration" Value="@RegisterPanel">
                                <RouteView @key="_panelKey"
                                           RouteData="@_activeModalProvider.BuildRouteData(_panelKey)"
                                           DefaultLayout="@typeof(EmptyLayout)" />
                            </CascadingValue>
                        </div>
                    </div>
                </div>
            </div>
        </BitStack>
    </BitModal>
}

<style>
    @((MarkupString)CreateContainerCss())

    .nav-panel {
        background-color: var(--bit-clr-bg-sec);
    }

    .nav-item-container {
        border-radius: 12px !important;
        margin-bottom: 4px !important;
        height: 18px !important;
    }

    .nav-selected-item-container {
        border-color: transparent !important;
    }
</style>

@code {
    private IModalProvider? _activeModalProvider;
    private string _panelKey = string.Empty;
    private string? _preOpenUrl;
    private IModalPanel? _panel;
    private bool _needsSessionInit = false;

    private ModalHostState ModalHostState => GetState<ModalHostState>();

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (_needsSessionInit && _activeModalProvider is not null)
        {
            _needsSessionInit = false;
            // call provider *after* first render
            await _activeModalProvider.OnModalOpenedAsync(CancellationToken);
        }

        await base.OnAfterRenderAsync(firstRender);
    }


    private void RegisterPanel(IModalPanel panel)
        => _panel = panel;

    protected override void OnInitialized()
    {
        Nav.LocationChanged += OnLocationChanged;
        ReadFromUri(Nav.Uri, requestStateHasChanged: false);
    }

    protected override void OnAfterRender(bool firstRender)
    {
        if (firstRender)
        {
            ReadFromUri(Nav.Uri, requestStateHasChanged: true);
        }
    }

    private void OnLocationChanged(object? sender, LocationChangedEventArgs e)
        => ReadFromUri(e.Location, requestStateHasChanged: true);

    private async void ReadFromUri(string fullUri, bool requestStateHasChanged)
    {
        var uri = new Uri(fullUri);
        var qs = HttpUtility.ParseQueryString(uri.Query);

        // check all the modal providers and ensure that the one 
        // we are navigating to matches.
        var match = ModalProviderSource
            .GetModalProviders()
            .FirstOrDefault(p => 
                !string.IsNullOrWhiteSpace(qs[p.ProviderKey]));

        var newPanel = match is null
            ? null
            : Normalize(qs[match.ProviderKey], match.DefaultPanel);

        var wasActive = _activeModalProvider is not null;
        var willBeActive = match is not null;

        if (willBeActive && !wasActive)
        {
            // Store previous URL (to restore when modal closes)
            _preOpenUrl = RemoveQueryParam(fullUri, match!.ProviderKey);

            // call modal provider hook to initialize
            await match!.OnModalOpeningAsync(CancellationToken);
            _needsSessionInit = true;
        }

        // Detect modal close
        if (!willBeActive && wasActive)
        {
            _preOpenUrl = null;
        }

        // Handle panel change (panel navigation)
        _activeModalProvider = match;
        var oldPanel = _panelKey;
        _panelKey = newPanel ?? string.Empty;

        // Always allow navigation between panels (no validation / save here)
        // Just avoid duplicate navigation
        if (oldPanel != _panelKey)
        {
            // nothing else to do
        }

        if (requestStateHasChanged)
            StateHasChanged();
    }

    private async Task CloseAsync()
    {
        // Check with current panel guard before closing
        if (_panel is not null)
        {
            var canClose = await _panel.CanCloseModalAsync();
            if (!canClose)
                return;
        }

        // Navigate to the original URL
        if (!string.IsNullOrEmpty(_preOpenUrl))
        {
            Nav.NavigateTo(_preOpenUrl!, replace: true);
        }
        // the preOpenUrl was empty, let's just deduce it from our current location.
        else if (_activeModalProvider is not null)
        {
            var stripped = Nav.GetUriWithQueryParameter(_activeModalProvider.ProviderKey, (string?)null);
            Nav.NavigateTo(stripped, replace: true);
        }

        _preOpenUrl = null;
        _activeModalProvider = null;
        _panelKey = string.Empty;
        _panel = null;
    }

    public override void Dispose()
    {
        Nav.LocationChanged -= OnLocationChanged;
        base.Dispose();
    }

    private static string ModalContainerClass = "modal-container";

    private string CreateContainerCss()
    {
        if (_activeModalProvider is null) return string.Empty;
        return $@"
        .{ModalContainerClass} {{
            width:  {_activeModalProvider.Width};
            height: {_activeModalProvider.Height};
            border-radius:20px;
        }}";
    }
    BitModalClassStyles ClassStyles = new()
    {
        Content = ModalContainerClass,
    };
    BitNavClassStyles NavStyles => new()
    {
        SelectedItemContainer = "nav-selected-item-container",
        ItemContainer = "nav-item-container",
        Item = "nav-item",
        SelectedItem = "nav-selected-item",
    };

}
