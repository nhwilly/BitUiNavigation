@inherits TimeWarpStateComponent
@inject NavigationManager NavManager
@inject IModalProviderSource ModalProviderSource
@inject ILogger<ModalHost> Logger
@implements IDisposable
@using BitUiNavigation.Client.Services
@using static UrlExtensions

@if (_activeModalProvider is not null)
{
    <BitModal IsOpen="true"
              OnOverlayClick="@TryCloseAsync"
              OnDismiss="@TryCloseAsync"
              Classes="@ClassStyles">

        <BitStack Horizontal Gap="0rem" Style="height: 100%">
            <BitStack Class="nav-panel" FitWidth Style="border-top-left-radius:20px; border-bottom-left-radius:20px;">
                <BitButton Style="margin: 1rem 0 0 1rem"
                           Color="BitColor.Tertiary"
                           OnClick="@TryCloseAsync"
                           IconOnly
                           Size="BitSize.Small"
                           IconName="@BitIconName.ChromeClose"
                           Variant="BitVariant.Text" />
                <NavSections NavSectionDetails="@(_activeModalProvider.BuildCustomNavSections(NavManager))" />
            </BitStack>


            <div style="flex:1;display:flex;flex-direction:column;height:100%">
                <div style="flex-shrink:0;border-top-right-radius:20px;">
                    <BitStack Horizontal Align="BitAlignment.SpaceBetween" Class="sticky-header" Style="padding: 0.75rem 1rem;">
                        <BitText Style="font-weight:600;">@(ModalHostState.)</BitText>

                        @if (_saveReset?.IsDirty == true)
                        {
                            var isBusy = _saveReset.IsSaving || _saveReset.IsResetting;

                            <BitStack Horizontal Gap="0.5rem">
                                @if (_saveReset.CanReset)
                                {
                                    <BitButton OnClick="@OnResetClicked"
                                               IsEnabled="@(!isBusy)"
                                               IconName="@BitIconName.Reset"
                                               Color="BitColor.Primary">
                                        Reset
                                    </BitButton>
                                }

                                @if (_saveReset.CanSave)
                                {
                                    <BitButton OnClick="@OnSaveClicked"
                                               IsEnabled="@(!isBusy)"
                                               IconName="@BitIconName.Save"
                                               Color="BitColor.Primary">
                                        Save
                                    </BitButton>
                                }
                            </BitStack>
                        }
                    </BitStack>
                </div>

                <BitSeparator Border="BitColorKind.Tertiary" />

                @if (_providerValidationMessages?.Count > 0)
                {
                    <BitText Style="padding:0 1rem; font-weight:600;" Color="@BitColor.Info">
                        Please resolve these issues:
                    </BitText>
                    <BitMessage Multiline Style="width: auto; margin: 0rem 1rem;" Color="@BitColor.Error">
                        <ul style="margin:0; padding-left:1rem;">
                            @foreach (var msg in _providerValidationMessages)
                            {
                                <li>@msg</li>
                            }
                        </ul>
                    </BitMessage>
                }

                <div style="flex:1;overflow:hidden;border-bottom-right-radius:20px;position:relative;">
                    <div style="height:100%;overflow-y:auto;">
                        <div style="padding:1rem;">
                            <CascadingValue TValue="@ModalContext" Value="@_ctx">
                                <RouteView @key="_panelName"
                                           RouteData="@_activeModalProvider.BuildRouteData(_panelName)"
                                           DefaultLayout="@typeof(EmptyLayout)" />
                            </CascadingValue>
                        </div>
                    </div>
                </div>
            </div>
        </BitStack>
    </BitModal>
}

<style>
    @((MarkupString)CreateContainerCss())

    .nav-panel {
        background-color: var(--bit-clr-bg-sec);
    }

    .nav-item-container {
        border-radius: 12px !important;
        margin-bottom: 4px !important;
        height: 18px !important;
    }

    .nav-selected-item-container {
        border-color: transparent !important;
    }
</style>

@code {
    private IModalProvider? _activeModalProvider;
    private string _panelName = string.Empty;
    private string? _preOpenUrl;
    private IModalPanel? _panel;
    private bool _needsSessionInit = false;
    private bool MissingPanelValidityBlocksClose => false; // flip to true if you want stricter policy
    private List<string>? _providerValidationMessages;
    private ModalHostState _hostState => GetState<ModalHostState>();
    private IModalSaveReset? _saveReset;
    private ModalProviderBase? _activeProviderBase;  // NEW

    private ModalContext _ctx => new()
    {
        ProviderKey = _activeModalProvider?.ProviderName ?? "UnknownProvider",
        PanelName = _panelName // or nameof(UserProfilePanel) if you map it
    };

    // NEW: Blocking dialog local state
    private bool _isDialogOpen;
    private string _dialogTitle = string.Empty;
    private string _dialogBody = string.Empty;
    private string _dialogPrimaryText = "OK";
    private string _dialogSecondaryText = "Cancel";
    private bool _showDialogSecondary;
    private EventCallback _onDialogPrimary;
    private EventCallback _onDialogSecondary;
    // CHANGED: Hook into your existing navigation/provider activation path to call SetActiveProvider(...)
    // e.g., after you determine which provider is active from the query string.

    // NEW: Save click handler
    private async Task OnSaveClicked()
    {
        if (_activeProviderBase is null || _saveReset is null) return;
        if (!_saveReset.IsDirty) return;

        var (isValid, _) = await _activeProviderBase.ValidateProviderAsync(CancellationToken);
        if (!isValid)
        {
            ShowInfoDialog(
                title: "Please fix validation issues",
                body: "Your changes contain validation problems. Correct them and try again.",
                primaryText: "OK"
            );
            return;
        }

        var ok = await _saveReset.SaveAsync(CancellationToken);
        if (!ok)
        {
            ShowInfoDialog(
                title: "Unable to save",
                body: "There was a problem saving your changes. Please try again.",
                primaryText: "OK"
            );
        }
        // No header projection to update here; buttons hide automatically when IsDirty flips in provider state.
    }

    private async Task OnResetClicked()
    {
        if (_saveReset is null) return;
        await _saveReset.ResetAsync(CancellationToken);
        // After reset, provider state should emit IsDirty=false via its TimeWarp.State; header will hide the buttons.
        StateHasChanged();
    }

    private async Task DiscardAndCloseAsync()
    {
        if (_saveReset is not null)
            await _saveReset.ResetAsync(CancellationToken);

        if (!string.IsNullOrEmpty(_preOpenUrl))
            NavManager.NavigateTo(_preOpenUrl!, replace: true);
        else if (_activeModalProvider is not null)
            NavManager.NavigateTo(NavManager.GetUriWithQueryParameter(_activeModalProvider.ProviderName, (string?)null), replace: true);

        _preOpenUrl = null;
        _activeModalProvider = null;
        _activeProviderBase = null;   // NEW
        _saveReset = null;             // NEW

        _isDialogOpen = false;
        StateHasChanged();
    }


    private void ShowInfoDialog(string title, string body, string primaryText)
    {
        _dialogTitle = title;
        _dialogBody = body;
        _dialogPrimaryText = primaryText;
        _dialogSecondaryText = string.Empty;
        _showDialogSecondary = false;
        _onDialogPrimary = EventCallback.Factory.Create(this, () => { _isDialogOpen = false; StateHasChanged(); });
        _onDialogSecondary = default;
        _isDialogOpen = true;
        StateHasChanged();
    }

    private void ShowConfirmDialog(string title, string body, string primaryText, string secondaryText, Func<Task> onPrimary, Action onSecondary)
    {
        _dialogTitle = title;
        _dialogBody = body;
        _dialogPrimaryText = primaryText;
        _dialogSecondaryText = secondaryText;
        _showDialogSecondary = true;

        _onDialogPrimary = EventCallback.Factory.Create(this, async () =>
        {
            _isDialogOpen = false;
            await onPrimary();
        });

        _onDialogSecondary = EventCallback.Factory.Create(this, () =>
        {
            _isDialogOpen = false;
            onSecondary();
            StateHasChanged();
        });

        _isDialogOpen = true;
        StateHasChanged();
    }

    private void SetActiveProvider(IModalProvider? provider)
    {
        _activeModalProvider = provider;
        _activeProviderBase = provider as ModalProviderBase; // NEW
        _saveReset = provider as IModalSaveReset;   // NEW
        StateHasChanged();
    }



    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            await ReadFromUri(NavManager.Uri, requestStateHasChanged: true);
        }

        if (_needsSessionInit && _activeModalProvider is not null)
        {
            _needsSessionInit = false;
            // call provider *after* first render
            await _activeModalProvider.OnModalOpenedAsync(CancellationToken);
        }

        await base.OnAfterRenderAsync(firstRender);
    }

    private bool CanCloseActiveProvider()
    {
        if (_activeModalProvider is null) return true;

        var providerKey = _activeModalProvider.ProviderName;

        // Normalize your keys the same way you publish them from ModalPanelBase / ModalContext
        var expectedPanelKeys = _activeModalProvider.ExpectedPanelKeys; // <-- now public

        return GetState<ModalHostState>()
            .ArePanelsValid(providerKey, expectedPanelKeys, MissingPanelValidityBlocksClose);
    }

    private void RegisterPanel(IModalPanel panel)
        => _panel = panel;

    private void HandleLocationChanged(object? sender, LocationChangedEventArgs e)
    {
        // fire-and-forget wrapper that calls your async method
        _ = OnLocationChanged(sender, e);
    }

    protected override async Task OnInitializedAsync()
    {
        NavManager.LocationChanged += HandleLocationChanged;
        await ReadFromUri(NavManager.Uri, requestStateHasChanged: false);
    }

    private async Task OnLocationChanged(object? sender, LocationChangedEventArgs e)
        => await ReadFromUri(e.Location, requestStateHasChanged: true);

    /// <summary>
    /// Inspects the provided URI and determines if it matches any of the model providers
    /// that were registered in dependency injection.  Selects a panel from the route
    /// or selects a default panel if none exists.  Finally it fires the OnModalOpeningAsync
    /// to allow the modal provider to initialize it's values.
    /// </summary>
    /// <param name="fullUri"></param>
    /// <param name="requestStateHasChanged"></param>
    private async Task ReadFromUri(string fullUri, bool requestStateHasChanged)
    {
        var uri = new Uri(fullUri);
        var qs = HttpUtility.ParseQueryString(uri.Query);

        // check all the modal providers and ensure that the one
        // we are navigating to matches.
        var match = ModalProviderSource
            .GetModalProviders()
            .FirstOrDefault(p =>
                !string.IsNullOrWhiteSpace(qs[p.ProviderName]));

        var newPanelName = match is null
            ? null
            : Normalize(qs[match.ProviderName], match.DefaultPanel);

        var wasActive = _activeModalProvider is not null;
        var willBeActive = match is not null;

        if (willBeActive && !wasActive)
        {
            // Store previous URL (to restore when modal closes)
            _preOpenUrl = RemoveQueryParam(fullUri, match!.ProviderName);

            Logger.LogDebug("OnModalOpeningAsync for provider '{ProviderName}'", match.ProviderName);
            // call modal provider hook to initialize
            await match!.OnModalOpeningAsync(CancellationToken);
            _needsSessionInit = true;
        }

        // Detect modal close
        if (!willBeActive && wasActive)
        {
            _preOpenUrl = null;
        }

        // Handle panel navigation
        _activeModalProvider = match;
        var oldPanelName = _panelName;
        _panelName = newPanelName ?? string.Empty;
        Logger.LogDebug("Changing panels from '{OldPanel}' to '{NewPanel}'", oldPanelName, newPanelName);

        if (requestStateHasChanged)
            StateHasChanged();
    }

    private async Task TryCloseAsync()
    {
        if (!CanCloseActiveProvider())
        {
            // show a toast/snack bar/banner as you like
            return;
        }
        // Optional provider-specific hook (non-blocking if you don't need it)
        if (_activeModalProvider is IBeforeCloseHook hook)
        {
            var ok = await hook.OnBeforeCloseAsync(CancellationToken);
            if (!ok) return;
        }









        // if (_activeModalProvider is not null)
        // {
        //     var (isValid, messages) = await _activeModalProvider.ValidateProviderAsync(CancellationToken);
        //     if (!isValid)
        //     {
        //         cache messages for UI and block close
        //         _providerValidationMessages = messages?.ToList() ?? [];
        //         StateHasChanged();
        //         return;
        //     }

        //     clear any prior provider errors
        //     _providerValidationMessages = null;
        // }

        // NEW: Save-or-discard flow
        if (_saveReset?.IsDirty == true)
        {
            if (_saveReset.SaveOnCloseEnabled)
            {
                var (valid, _) = await _activeProviderBase!.ValidateProviderAsync(CancellationToken);
                if (valid)
                {
                    var saved = await _saveReset.SaveAsync(CancellationToken);
                    if (!saved)
                    {
                        ShowInfoDialog(
                            title: "Unable to save before closing",
                            body: "There was a problem saving your changes. Please try again.",
                            primaryText: "OK"
                        );
                        return; // keep modal open
                    }
                }
                else
                {
                    ShowConfirmDialog(
                        title: "Discard changes and close?",
                        body: "You have unsaved changes with validation issues.",
                        primaryText: "Discard & Close",
                        secondaryText: "Cancel",
                        onPrimary: async () => { await DiscardAndCloseAsync(); },
                        onSecondary: () => { /* keep open */ }
                    );
                    return;
                }
            }
            else
            {
                ShowConfirmDialog(
                    title: "Discard changes and close?",
                    body: "You have unsaved changes.",
                    primaryText: "Discard & Close",
                    secondaryText: "Cancel",
                    onPrimary: async () => { await DiscardAndCloseAsync(); },
                    onSecondary: () => { /* keep open */ }
                );
                return;
            }
        }



        // proceed with existing close logic...
        if (!string.IsNullOrEmpty(_preOpenUrl))
        {
            NavManager.NavigateTo(_preOpenUrl!, replace: true);
        }
        // the preOpenUrl was empty, let's just deduce it from our current location.
        else if (_activeModalProvider is not null)
        {
            var stripped = NavManager.GetUriWithQueryParameter(_activeModalProvider.ProviderName, (string?)null);
            NavManager.NavigateTo(stripped, replace: true);
        }

        _preOpenUrl = null;
        _activeModalProvider = null;
        _panelName = string.Empty;
        _panel = null;
        _activeProviderBase = null;   // NEW
        _saveReset = null;             // NEW

    }

    public override void Dispose()
    {
        NavManager.LocationChanged -= HandleLocationChanged;
        base.Dispose();
    }

    private static readonly string ModalContainerClass = "modal-container";

    private string CreateContainerCss()
    {
        if (_activeModalProvider is null) return string.Empty;
        return $@"
        .{ModalContainerClass} {{
            width:  {_activeModalProvider.Width};
            height: {_activeModalProvider.Height};
            border-radius:20px;
        }}";
    }

    readonly BitModalClassStyles ClassStyles = new()
    {
        Content = ModalContainerClass,
    };

    static BitNavClassStyles NavStyles => new()
    {
        SelectedItemContainer = "nav-selected-item-container",
        ItemContainer = "nav-item-container",
        Item = "nav-item",
        SelectedItem = "nav-selected-item",
    };

}
